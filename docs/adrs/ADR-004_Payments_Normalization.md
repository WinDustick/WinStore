# ADR-004: Нормализация таблицы `Payments` и механизм проверки принадлежности заказа пользователю

## Статус

Принято (2025-05-09)

## Контекст

В таблице `Payments` присутствовал столбец `user_ID` и композитный внешний ключ `FK_Payments_Order_User` на `Orders(order_ID, user_ID)`. Это было сделано для обеспечения на уровне БД проверки, что платеж и заказ принадлежат одному пользователю, в том числе как мера безопасности.

## Рассмотренные варианты

1. **Оставить текущую структуру:** `Payments.user_ID` и композитный FK. Обеспечивает декларативную проверку в БД, но `user_ID` в `Payments` является избыточным, если он всегда совпадает с `Orders.user_ID`.

2. **Удалить `user_ID` из `Payments`:** Платеж связывается с заказом только через `order_ID`. Проверка, что пользователь, инициирующий платеж, является владельцем заказа, переносится полностью в прикладной уровень (или специализированную хранимую процедуру, вызываемую приложением).

## Принятое решение

Выбран Вариант 2 (Strictest AIC). Столбец `user_ID` и связанный с ним композитный внешний ключ `FK_Payments_Order_User` удалены из таблицы `Payments`. Уникальный ключ `UQ_Orders_Order_User` на `Orders(order_ID, user_ID)` сохранен как полезное ограничение для самой таблицы `Orders`.

## Обоснование

* **Соответствие "Absurdly Ideal Code" (Минимализм, Нормализация, SoC):** Таблица `Payments` упрощается, устраняется избыточность данных. `user_ID` является атрибутом заказа, а не неотъемлемым свойством самого платежа (в контексте, что плательщик всегда равен владельцу заказа).
* **Разделение Ответственности:** Бизнес-логика авторизации ("может ли пользователь X оплатить заказ Y?") относится к прикладному уровню.
* **Безопасность:** Основная защита от несанкционированного доступа и SQL-инъекций должна обеспечиваться на уровне приложения (параметризованные запросы, корректная авторизация сессии). Внешние ключи служат для поддержания целостности ссылочных данных.

## Последствия

* Прикладной уровень **обязан** перед созданием записи о платеже выполнять проверку, что аутентифицированный пользователь является владельцем `order_ID`. Невыполнение этой проверки в приложении создаст уязвимость.
* Запросы, которым ранее требовался `user_ID` непосредственно из `Payments`, теперь должны будут получать его через `JOIN` с `Orders` по `order_ID`.
* Упрощается схема таблицы `Payments`.

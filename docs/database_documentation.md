# Обновленная Документация Базы Данных "WinStore" (Версия от 2025-05-09)

## Введение: Философия Проектирования

При проектировании и реализации базы данных "WinStore" мы руководствуемся философией "Absurdly Ideal Code". Это означает стремление к максимальной **Надежности**, **Производительности** и **Простоте/Читаемости** одновременно. Ключевые принципы этой философии включают:

* **Максимальная Простота (KISS):** Создание простейшей и наиболее понятной архитектуры и кода.
* **Экстремальная Надежность:** Код должен быть корректным, устойчивым к граничным условиям и предсказуемо обрабатывать ошибки.
* **Пиковая Производительность:** Оптимизация кода с точки зрения алгоритмической эффективности и использования ресурсов.
* **Элегантность и Читаемость:** Чистый, идиоматичный и легко понимаемый код.
* **Минимализм:** Использование минимально необходимого количества абстракций и зависимостей.

В соответствии с этой философией, **сложная бизнес-логика**, включая расчеты скидок, применение промоакций, обновление агрегированных данных (например, суммы заказа или складских остатков) и управление состоянием бизнес-процессов, реализуется **исключительно на уровне бэкенд-приложения**. База данных фокусируется на эффективном хранении, извлечении данных и поддержании их целостности через декларативные ограничения (ключи, ограничения CHECK, внешние ключи). Использование хранимых процедур ограничено задачами предоставления простого интерфейса к данным или выполнения атомарных операций, не содержащих сложной бизнес-логики. Триггеры используются только для простейших задач, таких как обновление временных меток.

## Бизнес-правила и Структура Данных

### 1. Пользователи и Заказы:
* Каждый пользователь (`Users`) может создать множество заказов (`Orders`), однако каждый заказ обязательно привязан к конкретному пользователю. Это обеспечивается связью `FOREIGN KEY (user_ID) REFERENCES Users(user_ID)` в таблице `Orders`. Таблица `Users` включает `user_ROLE` (`NVARCHAR(50)`), `user_NAME` (`NVARCHAR(50)`).
* *Сегмент ER-диаграммы: Связь "один ко многим" между `Users` и `Orders`.*

### 2. Заказы и Элементы Заказа:
* Заказ (`Orders`) состоит из одного или нескольких элементов заказа (`OrderItems`). Таблица `Orders` теперь содержит `order_STATUS_ID` (внешний ключ к справочнику `OrderStatusTypes`). Расчет общей суммы заказа (`order_AMOUNT`) выполняется на уровне приложения.
* *Сегмент ER-диаграммы: Связь "один ко многим" между `Orders` и `OrderItems`.*

### 3. Элементы Заказа и Товары:
* Каждый элемент заказа (`OrderItems`) ссылается на один конкретный товар (`Products`). Обновление складских остатков (`Products.product_STOCK`) происходит на уровне приложения при обработке заказа.
* *Сегмент ER-диаграммы: Связь "многие к одному" от `OrderItems` к `Products`.*

### 4. Товары, Категории и Поставщики:
* Каждый товар (`Products`) принадлежит к категории (`Categories`) и поставляется поставщиком (`Vendors`). Поля `category_NAME`, `ven_NAME`, `ven_COUNTRY` используют `NVARCHAR`.
* *Сегмент ER-диаграммы: Связи "многие к одному" от `Products` к `Categories` и от `Products` к `Vendors`.*

### 5. Товары и Атрибуты Товаров:
* Индивидуальные характеристики товаров (`Products`) хранятся в `ProductAttributes`, связывая товар с атрибутом из справочника `Attributes`. Поле `att_NAME` в `Attributes` использует `NVARCHAR`. EAV-структура сохранена для гибкости.
* *Сегмент ER-диаграммы: Связь "многие ко многим" между `Products` и `Attributes` через `ProductAttributes`.*

### 6. Заказы и Платежи:
* Заказ (`Orders`) может иметь один или несколько платежей (`Payments`). **Таблица `Payments` больше не содержит `user_ID`.** Принадлежность платежа пользователю определяется через связь с заказом (`Payments.order_ID` -> `Orders.user_ID`). Проверка, что пользователь, инициирующий платеж, является владельцем заказа, выполняется на уровне приложения или специализированной хранимой процедуры перед созданием платежа. Поле `payment_STATUS_ID` является внешним ключом к справочнику `PaymentStatusTypes`. Поле `currency` использует `NCHAR(3)`.
* *Сегмент ER-диаграммы: Связь "один ко многим" между `Orders` и `Payments`.*

### 7. Заказы и Доставка (Упрощенная модель):
* **Таблица `Delivery` удалена.** Информация о доставке теперь хранится непосредственно в таблице `Orders` (поля `delivery_ADDRESS`, `shipped_DATE`, `estimated_delivery_DATE`, `actual_delivery_DATE`, `shipping_carrier_NAME`, `tracking_NUMBER`). Статус доставки (`delivery_STATUS_ID`) является внешним ключом к справочнику `DeliveryStatusTypes`. Эта модель выбрана, так как товары чаще всего доставляются вместе в рамках одного заказа с одного склада.
* *Сегмент ER-диаграммы: Поля доставки являются атрибутами таблицы `Orders`.*

### 8. Товары, Пользователи и Отзывы:
* Отзывы (`Review`) на товары (`Products`) оставляются пользователями (`Users`). Структура остается прежней, с уникальным ограничением на пару (пользователь, товар).
* *Сегмент ER-диаграммы: `Review` связана "многие к одному" с `Users` и `Products`.*

### 9. Товары и Медиафайлы (`ProductMedia`): 
* Структура сохранена.

### 10. Пользователи и Списки Желаний (`Wishlist`): 
* Структура сохранена.

### 11. Промоакции (`Promotions`, `PromotionApplications`): 
* Структура сохранена для гибкости. Поля `discount_TYPE`, `target_TYPE` используют `NVARCHAR`.

## Справочники Статусов:

* Введены следующие таблицы-справочники для управления статусами:
    * `OrderStatusTypes` (ID, Ключ, Наименование RU, Описание RU)
    * `PaymentStatusTypes` (ID, Ключ, Наименование RU, Описание RU)
    * `DeliveryStatusTypes` (ID, Ключ, Наименование RU, Описание RU)
* Таблицы `Orders` и `Payments` ссылаются на эти справочники через внешние ключи (`order_STATUS_ID`, `payment_STATUS_ID`, `delivery_STATUS_ID`). Это обеспечивает целостность данных, упрощает управление статусами и создает основу для локализации.

## Итоговая ER-диаграмма (концептуальное описание):

Итоговая ER-диаграмма включает таблицы: `Users`, `Orders` (с полями доставки), `OrderItems`, `Products`, `Categories`, `Vendors`, `Attributes`, `ProductAttributes`, `Payments`, `Review`, `ProductMedia`, `Wishlist`, `Promotions`, `PromotionApplications`, а также новые справочники `OrderStatusTypes`, `PaymentStatusTypes`, `DeliveryStatusTypes`. Связи между основными таблицами в целом сохраняются, за исключением удаления таблицы `Delivery` и изменения связей для статусов и `Payments.user_ID`.

## Возможности Оператора (Администратора)

* **Управление каталогом товаров:** Без существенных изменений в общих функциях, но данные для редактирования (например, используемые типы `NVARCHAR`) и связанные сущности (статусы) обновлены.
* **Управление пользователями:** Без существенных изменений.
* **Управление Промоакциями:** Без существенных изменений.
* **Обработка заказов и управление транзакциями:**
    * Статусы заказов и платежей теперь управляются через ссылки на справочники (`order_STATUS_ID`, `payment_STATUS_ID`).
    * Информация о доставке теперь редактируется напрямую в заказе.
* **Логистика и доставка:** Управление информацией о доставке осуществляется через поля в таблице `Orders`.
* **Отчётность и аналитика:** Отчеты по статусам будут использовать значения из справочников.

## Возможности Пользователя (Покупателя / Клиента)

* **Регистрация и учетная запись:** Без изменений.
* **Просмотр каталога и выбор товаров:** Без изменений.
* **Список желаний (Wishlist):** Без изменений.
* **Оформление заказа:**
    * Процесс применения промокодов остается прежним (логика в приложении).
    * Информация о доставке будет связана с заказом в целом.
* **Отслеживание заказа:**
    * Статус заказа и статус доставки отображаются на основе значений из справочников, получаемых через `order_STATUS_ID` и `delivery_STATUS_ID` в заказе.
* **Оставление отзывов:** Без изменений.

## Триггеры и Хранимые Процедуры

### Триггеры:
* `TR_Products_UpdateTimestamp`, `TR_Payments_UpdateTimestamp`: Сохранены для автоматического обновления временных меток.
* `TR_Orders_UpdateAmount`, `TR_OrderItems_AdjustStock`: **Удалены.** Соответствующая логика (расчет суммы заказа, обновление складских остатков) перенесена на уровень бэкенд-приложения.

### Хранимые Процедуры:
* Существующие хранимые процедуры (`sp_InsertProductWithAttributes`, `sp_AssociatePromoWithOrder`, `sp_GetPromotionDetails`, `sp_AddToWishlist`, `sp_GetWishlist`, `sp_AddProductMedia`) рассматриваются как тонкие обертки для доступа к данным или выполнения атомарных операций, не содержащих сложной бизнес-логики. Сложная логика валидации и бизнес-правила выполняются на уровне приложения перед вызовом этих процедур.
* Комплексная хранимая процедура `sp_ApplyPromotion` (если существовала с внутренней логикой расчета) удалена в пользу вынесения логики в приложение и использования `sp_AssociatePromoWithOrder`.

## Перенос Сложной Бизнес-Логики в Прикладной Уровень (Актуализировано)

Следующая сложная бизнес-логика была перенесена (или изначально предполагается) на прикладной уровень (бэкенд):

1. **Валидация и применение промоакций:** (Без изменений в описании, соответствует принципу)
2. **Расчет Суммы Заказа:** Общая сумма заказа (`Orders.order_AMOUNT`) рассчитывается приложением перед сохранением или обновлением заказа, на основе `OrderItems` и примененных скидок.
3. **Корректировка Складских Остатков:** `Products.product_STOCK` обновляется приложением при изменении статуса заказа (например, подтверждение, отмена), что требует транзакционного контроля на уровне приложения.
4. **Проверка Принадлежности Заказа Пользователю при Оплате:** Перед созданием записи в `Payments`, приложение **обязано** проверить, что аутентифицированный пользователь является владельцем `order_ID`, для которого создается платеж. Таблица `Payments` больше не содержит `user_ID`.
5. **Управление списком желаний:** (Без изменений в описании)
6. **Обработка медиафайлов товаров:** (Без изменений в описании)

Такое разделение обеспечивает лучшую тестируемость, поддерживаемость и масштабируемость системы.

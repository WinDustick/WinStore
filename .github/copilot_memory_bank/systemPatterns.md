# Архитектурные паттерны системы WinStore

## Основные паттерны архитектуры данных

### 1. Separation of Concerns (Разделение ответственности)

**Паттерн**: Четкое разделение ответственности между базой данных и прикладным уровнем.

**Реализация**:
- **База данных**: Отвечает за хранение, извлечение и целостность данных.
- **Прикладной уровень**: Отвечает за бизнес-логику, валидацию и управление состоянием.
- **Хранимые процедуры**: Используются только как тонкие обертки для доступа к данным или элементарных атомарных операций.
- **Триггеры**: Используются минимально, только для автоматического обновления служебных полей (timestamps).

**Пример**: Логика расчета суммы заказа и обновления складских остатков перенесена из триггеров SQL на уровень Django-приложения.

### 2. Status Lookup Tables (Справочные таблицы статусов)

**Паттерн**: Использование отдельных таблиц-справочников для хранения возможных статусов сущностей.

**Реализация**:
- Созданы таблицы `OrderStatusTypes`, `PaymentStatusTypes`, `DeliveryStatusTypes`.
- В основных таблицах используются внешние ключи на справочники вместо строковых значений с CHECK-ограничениями.
- Справочники содержат как технические ключи, так и локализованные отображаемые значения.

**Преимущества**: Нормализация, удобство локализации, расширяемость, производительность операций сравнения.

### 3. Entity-Attribute-Value (EAV) для атрибутов товаров

**Паттерн**: Использование гибкой структуры для хранения разнородных атрибутов товаров различных категорий.

**Реализация**:
- Таблицы `Attributes` и `ProductAttributes` для хранения характеристик товаров.
- Представления (views) с использованием PIVOT для удобного запроса конкретных атрибутов.

**Ограничения**: Высокая сложность запросов без использования представлений, потенциальные проблемы с производительностью при неоптимальном использовании.

### 4. Single Order Delivery (Единая доставка заказа)

**Паттерн**: Информация о доставке хранится на уровне заказа, а не отдельных позиций.

**Реализация**:
- Атрибуты доставки (адрес, статус, даты) хранятся непосредственно в таблице `Orders`.
- Единая точка отслеживания статуса доставки для всего заказа.

**Компромисс**: Упрощение модели с потерей возможности отслеживать доставку отдельных позиций заказа.

## Паттерны доступа к данным

### 1. Repository Pattern с Django ORM

**Паттерн**: Абстрактный доступ к данным через репозитории, скрывающие детали хранения.

**Реализация**:
- Django-модели как базовые репозитории.
- Дополнительные Manager-классы для более сложной логики доступа.
- Service-классы для бизнес-операций над репозиториями.

**Пример**: `OrderManager` расширяет стандартные методы модели `Order` для работы с заказами и их статусами.

### 2. Unit of Work (Транзакции)

**Паттерн**: Обеспечение атомарности бизнес-операций через транзакции.

**Реализация**:
- Django-транзакции (`transaction.atomic()`) для атомарных операций.
- Сервисные методы, объединяющие несколько операций в одну транзакцию.

**Пример**: Создание заказа и обновление складских остатков выполняются в одной транзакции.

### 3. Read Models (Представления для чтения)

**Паттерн**: Оптимизированные представления данных для чтения.

**Реализация**:
- SQL-представления (views) для преобразования нормализованных данных в плоскую структуру.
- PIVOT-запросы для EAV-структуры.

**Пример**: `view_gpu_details` для отображения всех характеристик видеокарт в удобном для запросов формате.

## Паттерны бизнес-логики

### 1. Domain Services (Доменные сервисы)

**Паттерн**: Инкапсуляция бизнес-логики в специализированных сервисных классах.

**Реализация**:
- Сервисные классы для каждой области бизнес-логики (заказы, платежи, промоакции).
- Валидация бизнес-правил перед выполнением операций.

**Пример**: `PromotionService.validate_and_apply_promotion()` для проверки и применения промокодов.

### 2. Authorization Context (Контекст авторизации)

**Паттерн**: Проверка прав доступа перед выполнением операций.

**Реализация**:
- Явная проверка прав пользователя на уровне сервисных методов.
- Декораторы Django для контроля доступа к API.

**Пример**: Проверка, что пользователь является владельцем заказа, перед созданием платежа.

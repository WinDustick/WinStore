# Технический регламент подсистемы генерации данных

**Версия:** 2.0.0
**Модуль:** Data Seeding & Simulation

## 1\. Архитектура и назначение

Подсистема генерации данных (`scripts/data_generation/`) предназначена для наполнения базы данных синтетической информацией, максимально приближенной к реальной. Она служит фундаментом для нагрузочного тестирования, проверки аналитических процедур и отладки механизмов аудита.

Процесс генерации построен на **слоистой архитектуре (Layered Architecture)** со строгой зависимостью уровней.

### 1.1. Уровни данных

1.  **Слой 0: Инфраструктура (Infrastructure Layer)**

      * **Компоненты:** Скрипты `reset.sql`, `deploy.sql`.
      * **Функция:** Создание схемы, табличных пространств, триггеров и пользователей БД.
      * **Статус:** Должен быть полностью инициализирован до запуска Python-скриптов.

2.  **Слой 1: Базовые сущности (Foundation Layer)**

      * **Скрипт:** `01_populate_base_entities.py`.
      * **Данные:** Справочники (`Categories`, `Attributes`, `Vendors`) и учетные записи пользователей (`Users`).
      * **Особенность:** Данные этого слоя имеют ограничения уникальности (`UNIQUE CONSTRAINTS`).

3.  **Слой 2: Товарный каталог (Catalog Layer)**

      * **Скрипты:** `products/generate_*.py`.
      * **Данные:** Карточки товаров (`Products`) и их характеристики (`ProductAttributes`).
      * **Зависимость:** Требует наличия вендоров и категорий из Слоя 1.

4.  **Слой 3: Транзакционная активность (Transaction Layer)**

      * **Скрипт:** `02_populate_orders.py`.
      * **Данные:** Заказы (`Orders`), состав заказов (`OrderItems`), платежи (`Payments`), аудит (`BusinessAuditLog`).
      * **Зависимость:** Требует наличия пользователей (Слой 1) и товаров (Слой 2).

-----

## 2\. Механизм кэширования идентификаторов (ID Cache)

Для обеспечения целостности связей (`Foreign Keys`) без выполнения дорогостоящих `SELECT` запросов при каждой вставке, подсистема использует локальный файловый кэш.

  * **Расположение:** `scripts/data_generation/generated_ids/*.json`.
  * **Состав:** JSON-файлы, содержащие списки ID созданных сущностей (`users.json`, `vendors.json` и др.).
  * **Принцип работы "File First":** Скрипты верхних уровней (например, генератор заказов) сначала ищут ID в JSON-файлах.
      * Если файл существует — данные берутся из него.
      * Если файл отсутствует — происходит Fallback-запрос к базе данных (`SELECT ID FROM ...`) для построения актуального списка.

-----

## 3\. Регламент полного цикла (Full Reset)

Используется для приведения базы данных в чистое предсказуемое состояние.

**Порядок выполнения:**

1.  **Сброс БД:** Выполнение `oracle/reset.sql` (удаление пользователей и сессий).
2.  **Деплой схемы:** Выполнение `oracle/deploy.sql`.
3.  **Базовые сущности:**
    ```bash
    python scripts/data_generation/01_populate_base_entities.py
    ```
    *Результат:* Создание пользователей и справочников, генерация файлов кэша в `generated_ids/`.
4.  **Каталог товаров:** Запуск необходимых генераторов из папки `products/` (CPU, GPU, RAM).
5.  **Генерация активности:**
    ```bash
    python scripts/data_generation/02_populate_orders.py
    ```

-----

## 4\. Сценарии частичного обновления (Iterative Seeding)

Скрипты имеют разную степень идемпотентности. Ниже описаны алгоритмы действий для типовых задач расширения данных.

### Сценарий А: Увеличение количества заказов

Необходимо сгенерировать дополнительную историю транзакций для существующих пользователей (например, для проверки производительности тяжелых отчетов).

  * **Анализ:** Скрипт `02_populate_orders.py` работает в аддитивном режиме.
  * **Действие:** Просто запустите скрипт повторно.
    ```bash
    python scripts/data_generation/02_populate_orders.py
    ```
  * **Результат:** К существующим заказам добавятся новые. Старые данные затронуты не будут.

### Сценарий Б: Добавление новых пользователей

Необходимо зарегистрировать новую партию пользователей и сразу сгенерировать для них активность.

  * **Проблема:** Скрипт `01_populate_base_entities.py` не идемпотентен. Повторный запуск вызовет ошибку `ORA-00001: unique constraint violated` при попытке дублирования категорий и вендоров.
  * **Алгоритм действий:**
    1.  **Модификация кода:** Временно отключите (закомментируйте) в `01_populate_base_entities.py` функции вызова `insert_vendors`, `insert_categories`, `insert_attributes`. Оставьте активной только `generate_users`.
    2.  **Генерация пользователей:** Запустите модифицированный скрипт. В БД добавятся только новые пользователи.
    3.  **Инвалидация кэша:** Удалите файл `generated_ids/users.json`.
          * *Причина:* В файле содержатся только старые ID. Если его не удалить, генератор заказов не "увидит" новых пользователей.
    4.  **Генерация заказов:** Запустите `02_populate_orders.py`.
          * *Логика:* Обнаружив отсутствие JSON-файла, скрипт выгрузит из БД полный актуальный список пользователей (старых + новых) и сгенерирует заказы для всех.

-----

## 5\. Обработка коллизий и ограничений

### 5.1. Уникальность данных

В таблицах `Vendors`, `Categories` и `Attributes` настроены жесткие ограничения уникальности (`UNIQUE`). Подсистема генерации не проверяет наличие записи перед вставкой (для ускорения `batch insert`), полагаясь на то, что база пуста.

  * **Ошибка:** `ORA-00001` при запуске `01_populate_base_entities.py`.
  * **Решение:** Выполнить полный сброс (Reset) или использовать метод из "Сценария Б".

### 5.2. Согласованность внешних ключей

Генераторы товаров (`products/`) используют `vendors.json` для привязки товара к производителю.

  * **Риск:** Если вручную удалить вендора из БД, но оставить его ID в `vendors.json`, генератор товаров упадет с ошибкой `ORA-02291` (FK violation).
  * **Решение:** При ручных манипуляциях с БД всегда удалять папку `generated_ids/` для принудительной синхронизации состояния скриптов и базы.

### 5.3. Парсинг и защита (Anti-Scraping)

Генератор CPU использует live-парсинг. При получении HTTP 429 (Too Many Requests) скрипт автоматически завершает работу, сохраняя уже добавленные данные (транзакция фиксируется на уровне батча). Повторный запуск скрипта безопасен (существует проверка на дубликаты товаров).
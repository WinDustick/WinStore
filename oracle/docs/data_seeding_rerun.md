### 1\. Общие принципы повторного запуска скриптов

Скрипты заполнения данных **не являются полностью идемпотентными**, что означает, что их нельзя просто запустить повторно в произвольном порядке. Это связано с наличием уникальных ограничений в базе данных и логикой кэширования ID.

#### 1.1. Ограничения скрипта `01_populate_base_entities.py`

Скрипт `01_populate_base_entities.py` создает основные сущности, такие как **Vendors**, **Categories** и **Attributes**, которые имеют уникальные названия в базе данных.

  * **Проблема при повторном запуске:** При попытке повторного выполнения скрипт попытается вставить те же записи (`INSERT INTO Categories...` и т.д.), что приведет к ошибке нарушения уникального ограничения (`UNIQUE constraint violated`), и выполнение всего скрипта будет прервано.
  * **Вывод:** Для добавления только новых пользователей необходимо использовать модифицированный подход (см. Сценарий 2). Не запускайте этот скрипт повторно без предварительной очистки базы данных или модификации самого скрипта.

#### 1.2. Поведение скрипта `02_populate_orders.py`

Скрипт `02_populate_orders.py` генерирует заказы для существующих пользователей.

  * **Поведение:** Скрипт работает в **аддитивном** режиме. Он генерирует новую порцию заказов для каждого пользователя, найденного в списке.
  * **Вывод:** Повторный запуск этого скрипта **добавит** новые заказы к уже существующей истории заказов, но не удалит и не изменит старые.

-----

### 2\. Управление кэшем ID (JSON-файлы)

Для оптимизации производительности и избежания частых запросов к базе данных, скрипты используют кэш первичных ключей (ID) в формате JSON, расположенный в директории `scripts/data_generation/generated_ids/`.

Ключевой файл для генерации заказов — это `users.json`, который содержит ID всех сгенерированных пользователей.

  * **Приоритет JSON:** Скрипт `02_populate_orders.py` **всегда** сначала пытается загрузить список ID пользователей из файла `users.json`. Если файл существует, он **игнорирует** данные в базе данных.
  * **Fallback на базу:** Если файл `users.json` **отсутствует** или был удален, скрипт `02_populate_orders.py` автоматически выполнит запрос к базе данных, чтобы получить актуальный список всех существующих ID пользователей.
  * **Важность синхронизации:** Если вы добавили новых пользователей вручную или с помощью модифицированного скрипта, но не удалили старый `users.json`, новые пользователи **не получат заказы** при следующем запуске `02_populate_orders.py`.

-----

### 3\. Сценарии "долива" данных

#### Сценарий 3.1: Добавление только новых заказов

Если вам нужно увеличить количество заказов для уже существующих в базе пользователей.

1.  **Проверка:** Убедитесь, что файл `users.json` в папке `generated_ids` существует и содержит актуальный список ID пользователей.
2.  **Действие:** Запустите скрипт генерации заказов:
    ```bash
    python scripts/data_generation/02_populate_orders.py
    ```
3.  **Результат:** Новые заказы будут добавлены в базу данных к существующей истории. Старые данные не будут затронуты.

#### Сценарий 3.2: Добавление только новых пользователей и заказов для них

Если вам нужно добавить новую партию пользователей и сразу сгенерировать для них заказы.

1.  **Модификация скрипта:** Откройте `scripts/data_generation/01_populate_base_entities.py`. Временно **закомментируйте** (или удалите) блоки кода, отвечающие за вставку **Vendors**, **Categories** и **Attributes**. Оставьте только блоки, связанные с генерацией и вставкой **Users**.
2.  **Добавление пользователей:** Запустите модифицированный скрипт:
    ```bash
    python scripts/data_generation/01_populate_base_entities.py
    ```
3.  **Сброс кэша:** **Удалите** файл кэша ID пользователей:
    ```bash
    rm scripts/data_generation/generated_ids/users.json
    ```
    *Это действие заставит скрипт заказов обратиться напрямую к БД.*
4.  **Добавление заказов:** Запустите скрипт генерации заказов:
    ```bash
    python scripts/data_generation/02_populate_orders.py
    ```
5.  **Результат:** Заказы будут сгенерированы для **всех** пользователей в базе данных (старых и новых), так как скрипт обновит свой список ID из БД.
6.  **Восстановление скрипта:** После завершения, **раскомментируйте** изменения в `01_populate_base_entities.py`, чтобы сохранить его оригинальную логику.
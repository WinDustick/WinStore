# Реестр триггеров базы данных (Trigger Registry)

## 1. Архитектурные принципы использования триггеров

В соответствии с философией AIC и архитектурным решением ADR-001 ("Business Logic To App Layer"), использование триггеров в проекте WinStore строго регламентировано. Триггеры применяются исключительно для служебных (инфраструктурных) задач, которые невозможно или нецелесообразно делегировать уровню приложения.

**Разрешенные сценарии:**
1.  **Генерация синтетических ключей (Surrogate Keys):** Заполнение первичных ключей из последовательностей (Sequences) для обеспечения совместимости с версиями Oracle, не поддерживающими `IDENTITY` колонки.
2.  **Аудит изменений (Audit Logging):** Фиксация факта изменения данных в журнале аудита.
3.  **Временные метки (Timestamping):** Автоматическое обновление поля `updated_at`.

**Запрещенные сценарии:**
* Бизнес-валидация (например, проверка баланса пользователя).
* Каскадные изменения бизнес-данных (кроме денормализации для отчетности, если это обосновано производительностью).

---

## 2. Группа: Генерация первичных ключей (Identity Generation)

**Расположение исходного кода:** `oracle/01_schema/01_core_schema.sql`
**Тип:** `BEFORE INSERT FOR EACH ROW`

Эти триггеры обеспечивают автоинкремент первичных ключей. Они срабатывают перед вставкой новой записи и запрашивают следующее значение (`NEXTVAL`) из соответствующей последовательности, присваивая его полю `:NEW.ID`.

| Имя триггера | Целевая таблица | Используемая последовательность | Описание |
| :--- | :--- | :--- | :--- |
| `TRG_USERS_BI` | `Users` | `SEQ_USERS_ID` | Генерация `user_ID`. |
| `TRG_CATEGORIES_BI` | `Categories` | `SEQ_CATEGORIES_ID` | Генерация `category_ID`. |
| `TRG_VENDORS_BI` | `Vendors` | `SEQ_VENDORS_ID` | Генерация `ven_ID`. |
| `TRG_ATTRIBUTES_BI` | `Attributes` | `SEQ_ATTRIBUTES_ID` | Генерация `att_ID`. |
| `TRG_PRODUCTS_BI` | `Products` | `SEQ_PRODUCTS_ID` | Генерация `product_ID`. |
| `TRG_PRODUCTMEDIA_BI` | `ProductMedia` | `SEQ_PRODUCTMEDIA_ID` | Генерация `media_ID`. |
| `TRG_WISHLIST_BI` | `Wishlist` | `SEQ_WISHLIST_ID` | Генерация `wishlist_ID`. |
| `TRG_PROMOTIONS_BI` | `Promotions` | `SEQ_PROMOTIONS_ID` | Генерация `promo_ID`. |
| `TRG_PROMOTIONAPPS_BI` | `PromotionApplications` | `SEQ_PROMOTIONAPPS_ID` | Генерация `app_ID`. |
| `TRG_ORDERS_BI` | `Orders` | `SEQ_ORDERS_ID` | Генерация `order_ID`. |
| `TRG_ORDERITEMS_BI` | `OrderItems` | `SEQ_ORDERITEMS_ID` | Генерация `OrderItems_ID`. |
| `TRG_PAYMENTS_BI` | `Payments` | `SEQ_PAYMENTS_ID` | Генерация `payment_ID`. |
| `TRG_REVIEWS_BI` | `Review` | `SEQ_REVIEWS_ID` | Генерация `rew_ID`. |
| `TRG_BUSINESSAUDITLOG_BI` | `BusinessAuditLog` | `SEQ_BUSINESSAUDITLOG_ID` | Генерация `audit_ID`. Находится в `02_audit`. |

---

## 3. Группа: Обслуживание временных меток (Timestamp Maintenance)

**Расположение исходного кода:** `oracle/05_triggers/triggers.sql`
**Тип:** `BEFORE UPDATE FOR EACH ROW`

Технические триггеры, обновляющие поле даты последней модификации записи. Гарантируют, что поле `updated_at` всегда содержит актуальное время сервера при любой операции `UPDATE`.

### `trg_products_bu_updated`
* **Таблица:** `Products`
* **Событие:** `BEFORE UPDATE`
* **Логика:** Присваивает `:NEW.updated_AT := SYSTIMESTAMP`.
* **Назначение:** Отслеживание изменений в каталоге товаров для кэширования и аудита.

### `trg_payments_bu_updated`
* **Таблица:** `Payments`
* **Событие:** `BEFORE UPDATE`
* **Логика:** Присваивает `:NEW.updated_at := SYSTIMESTAMP`.
* **Назначение:** Фиксация времени изменения статуса платежа.

---

## 4. Группа: Бизнес-аудит (Audit & Security)

**Расположение исходного кода:** `oracle/02_audit/audit_setup.sql`
**Тип:** `AFTER INSERT OR UPDATE OR DELETE FOR EACH ROW`

Триггеры этой группы отвечают за наполнение таблицы `BusinessAuditLog`. Они захватывают контекст операции и вызывают хранимую процедуру `sp_LogBusinessAuditEvent`.

### `TRG_AUDIT_ORDERS`
* **Таблица:** `Orders`
* **Событие:** `INSERT`, `UPDATE`, `DELETE`
* **Функционал:**
    * Определяет тип операции (`INSERT`/`UPDATE`/`DELETE`).
    * Извлекает `user_ID` из записи заказа для привязки действия к пользователю.
    * Создает запись в `BusinessAuditLog` с кратким описанием события.
    * **Специфика UPDATE:** При изменении статуса заказа (`order_STATUS_ID`) или статуса доставки (`delivery_STATUS_ID`) создает дополнительные детальные записи в аудите, указывая старое (`:OLD`) и новое (`:NEW`) значение.

### `TRG_AUDIT_PAYMENTS`
* **Таблица:** `Payments`
* **Событие:** `INSERT`, `UPDATE`, `DELETE`
* **Функционал:**
    * Аналогичен триггеру заказов.
    * Поскольку таблица `Payments` не содержит прямой ссылки на пользователя (только на `Orders`), триггер выполняет подзапрос для определения владельца заказа (`v_order_user_id`).
    * **Специфика UPDATE:** Отслеживает и детально логирует изменения статуса платежа (`payment_STATUS_ID`).

---

## 5. Технические особенности реализации

* **Независимость от приложения:** Работа триггеров гарантирует целостность служебных данных (ID, timestamps, audit) даже если изменения вносятся вручную через SQL-клиент администратором.
* **Производительность:**
    * Триггеры аудита используют `PRAGMA AUTONOMOUS_TRANSACTION` внутри вызываемой процедуры `sp_LogBusinessAuditEvent`, чтобы ошибки логирования не блокировали основную бизнес-транзакцию (если такая политика настроена) или для независимой фиксации логов. *Примечание: В текущей реализации `audit_setup.sql` процедура автономна.*
    * Триггеры ключей и таймстемпов являются легковесными и компилируются в нативный код (`PLSQL_OPTIMIZE_LEVEL=2` по умолчанию).
* **Обработка ошибок:** Ошибки внутри триггеров (например, невозможность получить `NEXTVAL`) приведут к откату всей транзакции (`ORA-XXXXX`), что предотвращает появление записей с некорректными идентификаторами.